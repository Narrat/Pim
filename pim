#!/usr/bin/env python3

# Copyright (c) 2010 James Campos

# ToDo
# mouse panning / keybinds

# Thanks
# alterecco, for making [visible](http://drop.dotright.net/visible) (dead),
# and inspiring me (James Campos) to make this program.


# Pim
# Python image viewer with vim-like keybindings
# v0.8.0

import argparse
from random import shuffle
import mimetypes
from threading import Thread
from gi import require_version
require_version('Gtk', '3.0')
from gi.repository import GLib, Gtk, Gdk, GdkPixbuf
import os
import shutil


class Pim:
    def __init__(self):
        self.cur_hide_delay = 2
        self.fullscreen = False
        self.geometry = "800x600"
        self.slideshow = False
        self.slideshow_delay = 5
        self.shuffle = False
        self.sbar = False
        self.zoom_lock = False

        self.current_image = None
        self.current_image_index = -1
        self.previous_image = None
        self.previous_image_index = -1
        self.next_image = None
        self.next_image_index = -1
        self.bg_thread = None

        self.paths = []
        self.marked = []

        self.binds = (
            # (modifier+key, function, args)
            # supported modifiers: Shift (through uppercase)
            # Ctrl (through ^), Alt (through Alt+)
            ("q", self.quit),
            ("Q", self.quit, True),
            ("f", self.toggle_fullscreen),
            ("b", self.toggle_statusbar),

            # if True, scroll in the horizontal direction.
            ("h", self.scroll, Gtk.ScrollType.STEP_BACKWARD, True),
            ("j", self.scroll, Gtk.ScrollType.STEP_FORWARD, False),
            ("k", self.scroll, Gtk.ScrollType.STEP_BACKWARD, False),
            ("l", self.scroll, Gtk.ScrollType.STEP_FORWARD, True),

            ("H", self.scroll, Gtk.ScrollType.PAGE_BACKWARD, True),
            ("J", self.scroll, Gtk.ScrollType.PAGE_FORWARD, False),
            ("K", self.scroll, Gtk.ScrollType.PAGE_BACKWARD, False),
            ("L", self.scroll, Gtk.ScrollType.PAGE_FORWARD, True),

            ("Left", self.scroll, Gtk.ScrollType.STEP_BACKWARD, True),
            ("Down", self.scroll, Gtk.ScrollType.STEP_FORWARD, False),
            ("Up", self.scroll, Gtk.ScrollType.STEP_BACKWARD, False),
            ("Right", self.scroll, Gtk.ScrollType.STEP_FORWARD, True),

            ("g", self.scroll, Gtk.ScrollType.START, False),
            ("G", self.scroll, Gtk.ScrollType.END, False),

            ("minus", self.zoom_delta, -.25),
            ("plus", self.zoom_delta, +.25),
            ("n", self.move_index, 1),
            ("p", self.move_index, -1),
            ("s", self.toggle_slideshow),
            ("t", self.set_slideshow_delay, 1),
            ("T", self.set_slideshow_delay, -1),
            ("X", self.delete, -1),
            ("x", self.delete, 0),
            ("z", self.toggle_zoom_lock),
            ("m", self.mark),

            ("1", self.zoom_to, 1),
            ("2", self.zoom_to, 2),
            ("3", self.zoom_to, 3),
            # Fit into window
            ("w", self.zoom_to, 0),
            ("e", self.zoom_to, 0, True, False),
            ("E", self.zoom_to, 0, False, True),

            ("greater", self.rotate, 1),
            ("less", self.rotate, 3),

            ("space", self.move_index, 1),
            ("SPACE", self.move_index, -1),
            )

    def toggle_zoom_lock(self):
        self.zoom_lock = not self.zoom_lock

    def delete(self, delta=0):
        current = self.paths[self.current_image_index]
        self.paths.remove(current)
        if current in self.marked:
            self.marked.remove(current)
        if os.path.exists(current):
            if not os.path.isdir('/tmp/pim-trash'):
                os.mkdir('/tmp/pim-trash')
            # Check if there is already a file with that name at /tmp/pim-trash
            delfile = "/tmp/pim-trash/"+os.path.basename(current)
            if os.path.exists(delfile):
                for i in range(0, 1000):
                    ndelfile = delfile+"."+str(i)
                    if not os.path.exists(ndelfile):
                        shutil.move(delfile, ndelfile)
                        break
            print("Moving {} into trash (/tmp/pim-trash/)".format(current))
            shutil.move(current, '/tmp/pim-trash')
        if len(self.paths) == 0:
            self.quit()
        else:
            self.move_index(delta)

    def quit(self, remember_position=False):
        if remember_position and len(self.paths):
            try:
                f = open('pim-position', 'w')
                f.writelines(self.paths[self.current_image_index])
                f.close()
            except IOError as e:
                print(e)
        for pos in self.marked:
            print(pos)

        Gtk.main_quit()

    def scroll(self, scrolltype, horizontal):
        self.scrolled_win.emit('scroll-child', scrolltype, horizontal)

    def toggle_slideshow(self):
        self.slideshow = not self.slideshow
        if self.slideshow:
            self.timer_id = GLib.timeout_add_seconds(self.slideshow_delay,
                                                     self.move_index, 1, True)
        else:
            GLib.source_remove(self.timer_id)
        self.update_info()

    def set_slideshow_delay(self, delta):
        if self.slideshow_delay == 1 and delta == -1:
            return
        else:
            self.slideshow_delay += delta
        if self.slideshow:
            self.toggle_slideshow()
            self.toggle_slideshow()

    def toggle_fullscreen(self):
        self.fullscreen = not self.fullscreen

        if self.fullscreen:
            self.win.fullscreen()
            # Save previous window size. Possible since get_size gets old value
            # And this is also the cause for some problems
            # (zoomfactor for fullscreen on non fullscreen window)
            self.Sizes['wSize'] = self.win.get_size()
        else:
            self.win.unfullscreen()
        if not self.zoom_lock:
            self.zoom_percent = self.get_zoom_percent()

        self.rescale_image()
        self.show_image()
        self.bg_rescale_next_image()

    def toggle_statusbar(self):
        if not self.sbar:
            Gtk.Widget.hide(self.statusbar)
        else:
            Gtk.Widget.show(self.statusbar)
        self.sbar = not self.sbar

    def rotate(self, cwise):
        self.current_image.rotate(cwise)
        if not self.zoom_lock:
            self.zoom_percent = self.get_zoom_percent()
            self.rescale_image()
        self.show_image()

    def get_zoom_percent(self, zWidth=False, zHeight=False):
        pboWidth = self.current_image.get_orig_width()
        pboHeight = self.current_image.get_orig_height()
        pboScale = pboWidth / pboHeight

        if self.fullscreen:
            winSize = (self.Sizes['sWidth'], self.Sizes['sHeight'])
            wScale = self.Sizes['sWidth'] / self.Sizes['sHeight']
        else:
            winSize = self.Sizes['wSize']
            wScale = self.Sizes['wSize'][0] / self.Sizes['wSize'][1]

        stickout = zWidth | zHeight
        if pboWidth < winSize[0] and pboHeight < winSize[1] and not stickout:
            return 1
        elif (pboScale < wScale and not stickout) or zHeight:
            return winSize[1] / pboHeight
        else:
            return winSize[0] / pboWidth

    def rescale_image(self):
        pboWidth = self.current_image.get_orig_width()
        pboHeight = self.current_image.get_orig_height()
        pbfWidth = int(pboWidth * self.zoom_percent)
        pbfHeight = int(pboHeight * self.zoom_percent)
        self.current_image.scale(pbfWidth, pbfHeight)

    def show_image(self):
        ''' Show the final image '''

        try:
            self.image.set_from_pixbuf(self.current_image.get_pixbuf())
        except:
            self.image.set_from_animation(self.current_image.get_unscaled_pixbuf())

        self.update_info()

    def parse_geometry(self):
        # Not nice, but adding type=int to argparse won't help because of the x
        # ToDo: Look for a better solution
        if self.geometry.find('x') >= 0:
            self.geometry = self.geometry.split('x')
            for ele in range(0, len(self.geometry)):
                if len(self.geometry[ele]) > 0:
                    self.geometry[ele] = int(self.geometry[ele])
                else:
                    print("::Warning: Missing geometry parameter."
                          " Replacing with default")
                    self.geometry[ele] = 200*(4-ele)
        else:
            print("::Warning: The geometry should be like that: 800x600"
                  "\n::Falling back to default")
            self.geometry = "800x600"
            self.parse_geometry()

    def set_default_window_size(self):
        self.parse_geometry()
        winWidth = self.geometry[0] if self.Sizes['sWidth'] >= 800 else self.Sizes['sWidth']
        winHeight = self.geometry[1] if self.Sizes['sHeight'] >= 600 else self.Sizes['sHeight']

        self.win.resize(winWidth, winHeight)
        if self.fullscreen:
            self.win.fullscreen()

    def update_info(self):
        message = "[{0}/{1}] [ {3:3.0f}% ]  {2: <50} {5: <3} {4: <11}".format(
            self.current_image_index+1, len(self.paths), self.paths[self.current_image_index],
            self.zoom_percent * 100, '[slideshow ({0}s)]'.format(self.slideshow_delay) \
                    if self.slideshow else '',
            '[*]' if self.paths[self.current_image_index] in self.marked else '')
        self.win.set_title("pim "+message)
        self.statusbar.push(1, message)

    def zoom_delta(self, delta):
        try:
            self.zoom_percent = self.zoom_percent + delta
            if self.zoom_percent <= 0:
                self.zoom_percent = 1/100
            self.rescale_image()
            self.show_image()
            self.bg_rescale_next_image()
        except:
            print("::Warning: Animation object cannot be zoomed")

    def zoom_to(self, percent, zWidth=False, zHeight=False):
        try:
            if not self.fullscreen:
                self.Sizes['wSize'] = self.win.get_size()
            self.zoom_percent = percent if percent else self.get_zoom_percent(zWidth, zHeight)
            self.rescale_image()
            self.show_image()
            self.bg_rescale_next_image()
        except:
            print("::Warning: Animation object cannot be zoomed")

    def bg_render_next_image(self, delta=1):
        self.next_image_index = (self.current_image_index + delta) % len(self.paths)
        def bg_renderer():
            path = self.paths[self.next_image_index]
            self.next_image = Image(path)
            pboWidth = self.next_image.get_orig_width()
            pboHeight = self.next_image.get_orig_height()
            pbfWidth = int(pboWidth * self.zoom_percent)
            pbfHeight = int(pboHeight * self.zoom_percent)
            self.next_image.scale(pbfWidth, pbfHeight)
        self.bg_thread = Thread(target=bg_renderer)
        self.bg_thread.start()

    def bg_wait_for_next_image(self):
        self.bg_thread.join()

    def bg_rescale_next_image(self):
        # This could be handled more efficiently, e.g. if we'd send some kind of signal to the
        # renderer thread in case it is still working.
        self.bg_wait_for_next_image()
        def bg_rescaler():
            pboWidth = self.next_image.get_orig_width()
            pboHeight = self.next_image.get_orig_height()
            pbfWidth = int(pboWidth * self.zoom_percent)
            pbfHeight = int(pboHeight * self.zoom_percent)
            self.next_image.scale(pbfWidth, pbfHeight)
        self.bg_thread = Thread(target=bg_rescaler)
        self.bg_thread.start()
        # We also have to invalidate previous image because of the changed dimensions
        self.previous_image_index = -1

    def move_index(self, delta, slide=False):
        # Manual interaction stops slideshow
        if self.slideshow and not slide:
            self.toggle_slideshow()

        new_image_index = (self.current_image_index + delta) % len(self.paths)

        new_previous_image = self.current_image

        # reshuffle on wrap-around
        if self.shuffle and new_image_index is 0 and delta > 0:
            shuffle(self.paths)

        path = self.paths[new_image_index]
        try:
            if self.previous_image_index == new_image_index:
                self.current_image = self.previous_image
            elif self.next_image_index == new_image_index:
                self.bg_wait_for_next_image()
                self.current_image = self.next_image
            else:
                self.current_image = Image(path)
                if self.current_image.is_static_image() and not self.zoom_lock:
                    if not self.fullscreen:
                        self.Sizes['wSize'] = self.win.get_size()
                    self.zoom_percent = self.get_zoom_percent()
                else:
                    self.zoom_percent = 1
                self.rescale_image()

            self.previous_image_index = self.current_image_index
            self.previous_image = new_previous_image
            self.current_image_index = new_image_index

            self.show_image()

            self.scroll(Gtk.ScrollType.START, False)
            self.scroll(Gtk.ScrollType.START, True)

        except GLib.Error as err:
            print(err)
            self.move_index(1)

        self.bg_render_next_image(1 if delta >= 0 else -1)

        return True  # for the slideshow

    def parse_args(self):
        usage = '%(prog)s [options] path1 [path2 path3 ...]'
        parser = argparse.ArgumentParser(usage=usage)
        parser.add_argument("-b", "--bar", action="store_true", dest="sbar",
                            help="display statusbar", default=self.sbar)
        parser.add_argument("-f", "--fullscreen", action="store_true",
                            dest="fullscreen", help="start in fullscreen",
                            default=self.fullscreen)
        parser.add_argument("-g", "--geometry", dest="geometry",
                            help="set window size", default=self.geometry)
        parser.add_argument("-s", "--shuffle", action="store_true",
                            dest="shuffle", help="shuffle filelist",
                            default=self.shuffle)
        parser.add_argument("-S", "--no-shuffle", action="store_false",
                            dest="shuffle", help="don't shuffle the filelist")
        parser.add_argument("--slideshow-delay", type=int,
                            help="set the slideshow delay",
                            default=self.slideshow_delay)
        parser.add_argument("path", nargs='+')
        args = parser.parse_args()
        self.sbar = args.sbar
        self.fullscreen = args.fullscreen
        self.geometry = args.geometry
        self.shuffle = args.shuffle
        self.slideshow_delay = args.slideshow_delay

        if not self.populate(args):
            parser.error('no loadable images detected')

    def populate(self, args):
        ''' Generate a list of paths from the given arguments '''

        # get supported mimetypes
        types = []
        for pixbuf_format in GdkPixbuf.Pixbuf.get_formats():
            types.extend(pixbuf_format.get_mime_types())

        args = args.path
        # If only one path is passed do special stuff
        single = None
        if len(args) is 1:
            arg = args[0]
            if os.path.isfile(arg):
                # use parent directory
                single = os.path.abspath(arg)
                directory = os.path.dirname(single)
                args = (directory,)
            elif os.path.isdir(arg) and os.path.isfile('pim-position'):
                f = open('pim-position')
                single = f.read()
                print("Found position file. Starting with: "+single)

        # add everything
        for arg in args:
            path = os.path.abspath(arg)
            if os.path.isfile(path):
                self.paths.append(path)
            elif os.path.isdir(path):
                paths = [os.path.join(path, x) for x in os.listdir(path)]
                paths.sort()
                self.paths.extend(paths)
            else:
                print("{} is not a valid path!".format(arg))

        # remove unsupported files
        self.paths = [path for path in self.paths if mimetypes.guess_type(path)[0] in types]

        # shuffle
        if self.shuffle:
            shuffle(self.paths)

        # complete special stuff for single arg
        if single and single in self.paths:
            self.current_image_index = self.paths.index(single)
        else:
            self.current_image_index = 0

        return len(self.paths)

    def mark(self):
        if self.paths[self.current_image_index] in self.marked:
            self.marked.remove(self.paths[self.current_image_index])
        else:
            self.marked.append(self.paths[self.current_image_index])
        self.update_info()

    def cursor_hide(self):
        self.win.get_window().set_cursor(Gdk.Cursor.new(Gdk.CursorType.BLANK_CURSOR))

    def handle_cursor_move(self, *unused):
        self.cur_timer_id = GLib.timeout_add_seconds(self.cur_hide_delay,
                                                     self.cursor_hide)
        self.win.get_window().set_cursor(None)

    def handle_key_press(self, widget, event):
        keyval = event.keyval
        keyname = Gdk.keyval_name(keyval)
        if keyval == Gdk.KEY_Shift_L or keyval == Gdk.KEY_Shift_R:
            return
        elif keyval == Gdk.KEY_Alt_L or keyval == Gdk.KEY_Alt_R:
            return
        elif keyval == Gdk.KEY_Control_L or keyval == Gdk.KEY_Control_R:
            return
        # Check for Modifier with keys that don't support them visibly
        specialkey = ("space", "Left", "Right", "Down", "Up", "greater", "less", "plus", "minus")
        if keyname in specialkey:
            keyname = '{}'.format(event.get_state() &
                                  Gdk.ModifierType.SHIFT_MASK and
                                  keyname.upper() or keyname.lower())
        # Check for Control (^) or Mod1 (Alt)
        if event.get_state() & Gdk.ModifierType.CONTROL_MASK:
            keyname = '^{}'.format(keyname)
        if event.get_state() & Gdk.ModifierType.MOD1_MASK:
            keyname = 'Alt+{}'.format(keyname)
        # Loop through binds until found (Calls for improvements)
        for bind in self.binds:
            if keyname == bind[0]:
                funk = bind[1]
                args = bind[2:]
                funk(*args)
                return
        print("::Warning: Unrecognized key:", event.string)

    def main(self):
        self.parse_args()

        screen = Gdk.Screen()
        self.Sizes = {}
        self.Sizes['sWidth'] = screen.width()
        self.Sizes['sHeight'] = screen.height()

        self.cur_timer_id = GLib.timeout_add_seconds(self.cur_hide_delay,
                                                     self.cursor_hide)

        self.win = Gtk.Window()
        self.win.add_events(Gdk.EventMask.KEY_PRESS_MASK |
                            Gdk.EventMask.POINTER_MOTION_MASK)
        self.win.connect('destroy', Gtk.main_quit)
        self.win.connect("key_press_event", self.handle_key_press)
        self.win.connect("motion-notify-event", self.handle_cursor_move)
        self.win.set_icon_name("image-x-generic")

        self.vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.win.add(self.vbox)

        self.scrolled_win = Gtk.ScrolledWindow()
        self.vbox.pack_start(self.scrolled_win, True, True, 0)

        viewport = Gtk.Viewport()
        viewport.modify_bg(Gtk.StateType.NORMAL, Gdk.color_parse('#999999'))
        viewport.set_shadow_type(Gtk.ShadowType.NONE)
        self.scrolled_win.add(viewport)

        self.set_default_window_size()
        self.Sizes['wSize'] = self.win.get_size()

        self.image = Gtk.Image()
        viewport.add(self.image)

        self.statusbar = Gtk.Statusbar()
        self.vbox.pack_end(self.statusbar, False, False, 0)

        self.move_index(0)
        self.win.show_all()
        if self.fullscreen:
            self.win.fullscreen()
        self.toggle_statusbar()
        Gtk.main()


class Image:
    """ Represents an image.

    Use it with:
    img = Image("path.jpg")
    img.scale(800, 600)
    gtkimagewidget.set_from_pixbuf(img.get_pixbuf()).

    You MUST scale() the Image before using get_pixbuf().
    """

    def __init__(self, path):
        if not os.path.exists(path):
            raise Exception("::Error: Couldn't open", path)
        else:
            self._pixbuf_unscaled = GdkPixbuf.PixbufAnimation.new_from_file(path)
        self._static_image = self._pixbuf_unscaled.is_static_image()
        if self._static_image:
            self._pixbuf_unscaled = self._pixbuf_unscaled.get_static_image()
        self._pixbuf_scaled = None

    def rotate(self, cwise):
        try:
            self._pixbuf_unscaled = self._pixbuf_unscaled.rotate_simple((90*cwise))
        except:
            print("::Warning: Animation object cannot be rotated")

    def get_orig_width(self):
        return self._pixbuf_unscaled.get_width()

    def get_orig_height(self):
        return self._pixbuf_unscaled.get_height()

    def scale(self, new_width, new_height):
        self._pixbuf_scaled = self._pixbuf_unscaled.scale_simple(new_width, new_height,
                GdkPixbuf.InterpType.BILINEAR)

    def get_pixbuf(self):
        return self._pixbuf_scaled

    def get_unscaled_pixbuf(self):
        # Intended for animations...
        return self._pixbuf_unscaled

    def is_static_image(self):
        return self._static_image


if __name__ == '__main__':

    Pim().main()
